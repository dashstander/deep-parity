---
title: "Perceptron Parity"
author: "Dashiell Stander"
format:
    html:
        code-fold: true
jupyter: python3
---


# Mathematical Preliminaries

We are going to be talking about functions on the _boolean cube_ $\{ -1, \; 1\}^n$.

We will denote $[n] = \{1, 2, 3, \dots, n \}$.

One of the most important boolean functions is $\chi_S: \{ -1, \; 1 \}^n \rightarrow \{-1, 1 \}$. $\chi_S$ is the **parity** of $S$ which is a subset of $[n]$:

$$\chi_S(x) = \prod_{i \in S} x_i $$

$$ \chi_S(x) $$  counts the number of -1s in the $S$ indices of $x$. If there is an even number of -1s then we can pair them all off. Since $-1^2 = 1$, if there is an even number of -1s then $\chi_S(x) = 1$. If there's an odd number then of -1s then there is an extra -1 left over and $\chi_S(x) = -1$.

The traditional basis for functions $f: \{-1, \; 1 \}^n \rightarrow \mathbb{R} $ is the "indicator" basis. We can think of the majority function on $\{-1, \; 1 \}^3$ as a map from each element of  $\{-1, \; 1 \}^3$ like so:

\begin{align}
(1, 1, 1) &\mapsto 1 \\
(-1, 1, 1) &\mapsto 1 \\
(1, -1, 1) &\mapsto 1 \\
(-1, -1, 1) &\mapsto -1 \\
(1, 1, -1) &\mapsto 1 \\
(-1, 1, -1) &\mapsto -1 \\
(1, -1, -1) &\mapsto -1 \\
(-1, -1, -1) &\mapsto -1 \\
\end{align}


# My Neural Network

```{python3}
# Set up
import numpy as np
import jax
import jax.numpy as jnp

from deep_parity.jax.boolean_cube import fourier_transform, generate_all_binary_arrays

from pathlib import Path

import polars as pl
from plotnine import ggplot, qplot, aes, geom_point, geom_histogram, facet_wrap, labs

from google.cloud import storage
import equinox as eqx

import treescope 

treescope.basic_interactive_setup(autovisualize_arrays=True)


def try_load_checkpoint(model_template, bucket_name, config, step):
    """Try to load the latest checkpoint from GCS bucket"""
    client = storage.Client()
    bucket = client.get_bucket(bucket_name)
    
    # Find checkpoints
    n = config['model']['n']
    seed = config['seed']
    model_dim = config['model']['model_dim']
    checkpoint_dir = f"full/one-layer/model_dim={model_dim}/n={n}/seed={seed}"
    blobs = list(bucket.list_blobs(prefix=f"{checkpoint_dir}/model_"))
    
    if not blobs:
        print("No checkpoints found, starting fresh training")
        return None
    
    # Download latest checkpoint files
    model_blob = bucket.blob(f"{checkpoint_dir}/model_{step}.eqx")
    model_local_path = f"/tmp/model_{step}.eqx"
    model_blob.download_to_filename(model_local_path)

  
    model = eqx.tree_deserialise_leaves(model_local_path, model_template)
    
    return model


def try_load_fim(bucket_name, config, step):
    client = storage.Client()
    bucket = client.get_bucket(bucket_name)
    
    n = config['model']['n']
    seed = config['seed']
    model_dim = config['model']['model_dim']
    checkpoint_dir = Path(f"fisher_information_matrix/one-layer/model_dim={model_dim}/n={n}/seed={seed}")
        
    # Download latest checkpoint files
    tensor_blob = bucket.blob(str(f"{checkpoint_dir}/{step}/fim{step}.npy"))
    tensor_blob_path = f"/tmp/{step}.npy"
    tensor_blob.download_to_filename(tensor_blob_path)
    
    return np.load(tensor_blob_path)


```




```{ojs}
data = FileAttachment("palmer-penguins.csv").csv({ typed: true })
```

```{ojs}
viewof bill_length_min = Inputs.range(
  [32, 50], 
  {value: 35, step: 1, label: "Bill length (min):"}
)
viewof islands = Inputs.checkbox(
  ["Torgersen", "Biscoe", "Dream"], 
  { value: ["Torgersen", "Biscoe"], 
    label: "Islands:"
  }
)
```
```{ojs}
filtered = data.filter(function(penguin) {
  return bill_length_min < penguin.bill_length_mm &&
         islands.includes(penguin.island);
})
```
```{ojs}
Plot.rectY(filtered, 
  Plot.binX(
    {y: "count"}, 
    {x: "body_mass_g", fill: "species", thresholds: 20}
  ))
  .plot({
    facet: {
      data: filtered,
      x: "sex",
      y: "species",
      marginRight: 80
    },
    marks: [
      Plot.frame(),
    ]
  }
)
```